import diff from 'deep-diff';
import dgraph from 'dgraph-js';
import fs from 'fs';
import grpc from 'grpc';

const create_client = host => {
  const client_stub = new dgraph.DgraphClientStub(host, grpc.credentials.createInsecure());
  return new dgraph.DgraphClient(client_stub);
}

const check_file_exists = file_path => {
  try {
    if (fs.existsSync(file_path)) {
      return true;
    }
    return false
  } catch (error) {
    console.error(error);
  }
}

const get_schema_from_path = async path => {
  if (path) {
    console.log('Now using file at path:', path);
    if (check_file_exists(path)) {
      return import(path);
    }
    return false;
  }
  const file_path = `${process.cwd()}/schema.js`;
  if (check_file_exists(file_path)) {
    return import(file_path);
  }
  return false;
}

const get_schema = async client => (await client.newTxn().query('schema {}')).getJson();

const prepare_value_string = predicate => {
  if (!predicate.endsWith('.')) throw new Error('Missing dot at the end of predicate, or incorrect spacing.');
  return predicate.split(' ').slice(0, -1)
};

const type_check = (type, object) => {
  const normal_types = ['default', 'bool', 'datetime', 'float', 'geo', 'int', 'password', 'string', 'uid'];
  const list_types = ['[default]', '[bool]', '[datetime]', '[float]', '[geo]', '[int]', '[string]', '[uid]'];
  const type_is_not_alist = normal_types.some(value => value === type);
  const type_is_list = list_types.some(value => value === type);
  if (!type_is_not_alist && !type_is_list) {
    throw new Error('Incorrect or missing type in predicate.');
  } else if (type_is_list) {
    object.type = type.slice(1, -1);
  } else {
    object.type = type;
  }
  if (type_is_list) {
    object.list = true;
  }
};

const index_check = (values_array, object) => {
  const tokenizer_array = [];
  const index = values_array.some(value => {
    if (value.includes('@index')) {
      if (value.slice(6, 7) !== '(' || value.slice(-1) !== ')') {
        throw new Error('@index is invalid, missing parenthesis or there are spaces in tokenizer.');
      }
      const fields = value.slice(7, -1).split(',');
      fields.forEach(field => {
        tokenizer_array.push(field.trim());
      });
      return true;
    }
    return false;
  });
  if (index) {
    object.index = index;
    object.tokenizer = tokenizer_array;
  }
};

const other_options = (values_array, object) => {
  values_array.forEach(value => {
    if (value.includes('@upsert')) {
      object.upsert = true;
    } else if (value.includes('@lang')) {
      object.lang = true;
    }
  })
}

const create_json_schema = schema => {
  const json_schema = [];
  Object.entries(schema).forEach(([key, value]) => {
    const object = { predicate: key };
    const predicates_array = prepare_value_string(value);
    try {
      type_check(predicates_array[0], object);
    } catch (error) {
      console.error(error);
    }
    predicates_array.shift();
    try {
      index_check(predicates_array, object);
    } catch (error) {
      console.error(error);
    }
    other_options(predicates_array, object);
    json_schema.push(object);
  });
  return json_schema;
}

const create_json_types = types => {
  const json_types = [];
  Object.entries(types).forEach(([key, value]) => {
    const object = { name: key };
    const fields = value.map(field => ({ name: field }));
    object.fields = fields;
    json_types.push(object);
  });
  return json_types;
}

// Custom comparator for sorting our schema
const compare_predicate_object = (object_a, object_b) => {
  const predicate_a = object_a.predicate.toUpperCase();
  const predicate_b = object_b.predicate.toUpperCase();

  return predicate_a.localeCompare(predicate_b)
}

// Custom comparator for sorting types
const compare_name_object = (object_a, object_b) => {
  const predicate_a = object_a.name.toUpperCase();
  const predicate_b = object_b.name.toUpperCase();

  return predicate_a.localeCompare(predicate_b)
}

const prepare_new_schema = schema_file => {
  const { schema, types } = schema_file;
  const sorted_schema = create_json_schema(schema).sort(compare_predicate_object);
  const sorted_types = create_json_types(types).sort(compare_name_object);
  return {
    schema: sorted_schema,
    types: sorted_types,
  };
}

// Removes Dgraph autogenerated predicates & types
const remove_dgraph_data = uneprepared_schema => {
  for (let i = 0; i < uneprepared_schema.schema.length; i++) {
    if (uneprepared_schema.schema[i].predicate === 'dgraph.graphql.schema') {
      uneprepared_schema.schema.splice(i, 1);
      break;
    }
  }
  for (let i = 0; i < uneprepared_schema.schema.length; i++) {
    if (uneprepared_schema.schema[i].predicate === 'dgraph.type') {
      uneprepared_schema.schema.splice(i, 1);
      break;
    }
  }
  for (let i = 0; i < uneprepared_schema.types.length; i++) {
    if (uneprepared_schema.types[i].name === 'dgraph.graphql') {
      uneprepared_schema.types.splice(i, 1);
      break;
    }
  }
  return uneprepared_schema;
}

const prepare_current_schema = async client => {
  const fetched_schema = await get_schema(client);
  const formated_schema = remove_dgraph_data(fetched_schema);
  formated_schema.schema.sort(compare_predicate_object);
  formated_schema.types.sort(compare_name_object);
  return formated_schema;
}

const compare_types_fields = (field_a, field_b) => {
  const type_a = field_a.name.toUpperCase();
  const type_b = field_b.name.toUpperCase();

  let comparator = 0;
  if (type_a > type_b) {
    comparator = 1;
  } else if (type_a < type_b) {
    comparator = -1;
  }
  return comparator;
}

const diff_types_checker = (new_schema, current_schema) => {
  const conflicts = [];
  const added = [];
  const types_to_check = [];
  const missing_types = [];

  new_schema.types.forEach(type => {
    type.fields.sort(compare_types_fields);
    types_to_check.push(type.name);
  });

  current_schema.types.forEach(type => {
    type.fields.sort(compare_types_fields);
    if (!types_to_check.includes(type.name)) {
      missing_types.push(type.name);
    }
  });

  types_to_check.forEach(type => {
    const new_object = new_schema.types.find(object => object.name === type);
    const current_object = current_schema.types.find(object => object.name === type);
    const differences = diff(current_object, new_object);
    if (typeof differences !== 'undefined') {
      differences.forEach(difference => {
        if (difference.kind === 'E') {
          conflicts.push({
            message: `This object was edited at path: ${difference.path[0]}`,
            category: 'types',
            object: { ...current_object },
            additional_information: `Expected ${difference.lhs} found ${difference.rhs}`,
          });
        } else if (difference.kind === 'N') {
          added.push({
            message: 'This new object was added.',
            category: 'types',
            object: { ...new_object },
          });
        } else if (difference.kind === 'A') {
          conflicts.push({
            message: 'Change in the fields in this object.',
            category: 'types',
            object: current_object,
          });
        }
      });
    }
  });

  missing_types.forEach(type => {
    const deleted_object = current_schema.types.find(object => object.name === type);
    conflicts.push({
      message: 'This object was deleted.',
      category: 'types',
      object: { ...deleted_object },
    });
  });

  return [conflicts, added];
}

const diff_schema_checker = (new_schema, current_schema) => {
  const conflicts = [];
  const added = [];
  const predicates_to_check = new_schema.schema.map(({ predicate }) => predicate);
  const missing_predicates = current_schema.schema
    .filter(({ predicate }) => !predicates_to_check.includes(predicate))
    .map(({ predicate }) => predicate);

  predicates_to_check.forEach(predicate => {
    const new_object = new_schema.schema.find(object => object.predicate === predicate);
    const current_object = current_schema.schema.find(object => object.predicate === predicate);
    const differences = diff(current_object, new_object); // Can have multiple diff for 1 object
    if (typeof differences !== 'undefined') {
      differences.forEach(difference => {
        if (difference.kind === 'E') {
          conflicts.push({
            message: `This object was edited at path:${difference.path[0]}`,
            category: 'schema',
            object: { ...current_object },
            additional_information: `Expected${difference.rhs}found${difference.lhs}`,
          });
        } else if (difference.kind === 'N') {
          if (typeof current_object === 'undefined') {
            added.push({
              message: 'This object was added.',
              object: { ...new_object },
            });
          } else {
            conflicts.push({
              message: 'This object was edited',
              category: 'schema',
              object: { ...new_object },
            });
          }
        } else if (difference.kind === 'D' && difference.path[0] === 'list') {
          conflicts.push({
            message: 'This object was edited, should be a list.',
            category: 'schema',
            object: { ...new_object },
          });
        } else if (new_object?.index && difference.kind === 'A') {
          conflicts.push({
            message: 'Tokenizer of this objects was edited.',
            category: 'schema',
            object: { ...current_object },
          });
        }
      });
    }
  });
  missing_predicates.forEach(predicate => {
    const deleted_object = current_schema.schema.find(object => object.predicate === predicate);
    conflicts.push({
      message: 'This object was deleted.',
      object: { ...deleted_object },
    });
  });

  return [conflicts, added];
}

const format_to_raw_schema = schema => Object.entries(schema).map(([key, value]) => `${key}: ${value}`).join('\n')

const format_to_raw_types = types => Object.entries(types).map(([key, value]) => {
  const values = value.map(sub_value => `\n\t${sub_value}`).join('');
  return `\ntype ${key} {${values}\n}`;
}).join('')

const alter_schema = async (client, schema_file) => {
  const { schema, types } = schema_file;
  const raw_schema_string = format_to_raw_schema(schema);
  const raw_types_string = format_to_raw_types(types);
  const raw_string = `${raw_types_string}\n${raw_schema_string}`;
  const operation = new dgraph.Operation();
  operation.setSchema(raw_string);
  try {
    await client.alter(operation);
  } catch (error) {
    console.log(error);
  }
}

const diff_checker = async (client, schema_file) => {
  const new_schema = prepare_new_schema(schema_file);
  const current_schema = await prepare_current_schema(client);
  const types_differences = diff_types_checker(new_schema, current_schema);
  const schema_differences = diff_schema_checker(new_schema, current_schema);
  const conflicts = [...types_differences[0], ...schema_differences[0]];
  const added = [...types_differences[1], ...schema_differences[1]];

  return [conflicts, added];
}

export default {
  create_client,
  get_schema,
  diff_checker,
  alter_schema,
  get_schema_from_path,
}
